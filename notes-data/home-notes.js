const commonData = {
    commonNote: [

        {
            id: 1,
            title: "aff intro",
            note: [
                {
                    text1: `
            AFF 
            ===========
            American First Finance provides finance service and help consumers obtain payment plans to purchase the goods and services that they want and at the same time help merchants and service suppliers increase sales. They can approve up to 80% of consumers, and offer a world class customer service experience.
            
            American First Finance helps consumers obtain payment plans to purchase what they want and at the same time help merchants increase sales. We can approve up to 80% of consumers, and offer a world class customer service experience.
            
            AFF offer programs with over 86% approval rates. In most cases our customers can be approved instantly by filling out a simple one page application.
            ----------
            Get approval amounts from $300 up to $5,000‚Ä† and enjoy a network of 20,000+ stores to choose from.
            Simply find a store and apply online with AFF. If approved, we'll give you the ability to transact at the store you selected.
            Our network of fine merchants includes stores you already know and love - here are just a few!
            ---------
            RISA Retail Installment Sales Agreement (closed-end, interest-bearing)
            Lease-to-own (‚ÄúLTO‚Äù) (uses a ‚Äúturn‚Äù or multiple)
            Bank Installment Loan - Merchant Funded (closed-end, interest-bearing)
            Bank Installment Loan - Consumer Funded (closed-end, interest-bearing)
            Bank 2-Tier ‚Äútrue-secondary‚Äù point-of-sale (‚ÄúPOS‚Äù) Installment Loan (closed-end, interest-bearing)
            Bank Line of Credit (open-end, fee-based) - launching 2020!
            -----------
            A rent-to-own lease refers to an alternative method of acquiring quality household items like furniture (including mattresses), appliances, electronics, or other consumer goods. Also known as a lease-to-own payment plan, this option can allow consumers with bad credit an option to access products without making substantial upfront payments.
            ===========
            `
                }
            ]
        },
        {
            id: 52,
            title: "AFF",
            note: [
                {
                    text1: `American First Finance offers a variety of financial products and services designed to provide flexible payment options, especially for individuals with less-than-perfect credit. Their offerings include:

<b>Retail Installment Sales Contracts</b>: These agreements allow consumers to purchase products and pay over time through amortizing payment schedules, with flexible early payoff options. 

<b>Lease Purchase Agreements</b>: In these agreements, American First Finance buys merchandise from a merchant and leases it to the consumer with flexible renewal payments. 

<b>Bank Loans</b>: Offered in partnership with FinWise Bank, these are secured and unsecured installment loans that can fund either the merchant or the consumer directly. 

<b>Flexible Payment Options</b>: Approval amounts range from $300 to $5,000, with access to a network of over 20,000 stores. Consumers can apply online and receive approval decisions in minutes. 

<b>Products Financing</b>: Consumers can obtain financing for a variety of products and services, including furniture, appliances, electronics, jewelry, auto repairs, dental work, and more.`,
                    code1: ``
                }
            ],
        },
        {
            id: 52,
            title: "LTO and RISA",
            note: [
                {
                    text1: `<b>1. LTO (Lease-To-Own)</b>:
Lease-To-Own (LTO) is a type of financing option that allows consumers to lease a product with the option to own it after completing a series of payments. It's a flexible alternative to traditional credit or financing that typically doesn't require a large upfront payment.

How it works:
-> Customers pay for the item over time through periodic payments (usually weekly, bi-weekly, or monthly).
-> At the end of the leasing period, customers have the option to purchase the product by paying a nominal "buyout" fee or by completing the lease payments.
-> If the customer doesn't complete the purchase, they may return the product or continue leasing it.

Common Uses:
-> LTO is commonly used for durable goods like electronics, furniture, appliances, and jewelry.
-> It's often used by consumers who may not have access to traditional credit or prefer not to use credit for large purchases.

<b>2. RISA (Retail Installment Sales Agreement)</b>:
A Retail Installment Sales Agreement (RISA) is a financial contract that allows consumers to purchase goods and pay for them in installments over time. Unlike leases, a RISA typically involves the customer buying the product outright with the understanding that they will make periodic payments (e.g., monthly) for the duration of the agreement.

How it works:
-> The customer agrees to make fixed payments over a specified period of time, usually with interest.
-> The retailer provides the product to the customer at the point of sale, and the customer owns the product once the agreement is signed, even though they haven't paid the full amount yet.
-> The payments can be made monthly or through other agreed-upon schedules.

Common Uses:
-> RISAs are typically used for higher-value items like furniture, appliances, electronics, or vehicles where the customer might not be able to afford the full purchase price upfront.
-> Key Differences Between LTO and RISA:
-> Ownership: With LTO, the customer generally leases the product with an option to own it at the end of the lease period, while with RISA, the customer immediately owns the product but agrees to make installment payments.
-> Payment Flexibility: LTO may offer more flexibility in terms of returning the product if the customer decides not to purchase it. In contrast, RISA usually does not offer the option to return the product unless the customer defaults on the payments.

Interest and Fees: RISAs typically involve an interest rate on the remaining balance of the product, whereas LTO agreements can sometimes have higher fees or interest rates due to the flexibility they offer.`,
                    code1: ``
                }
            ],
        },
        {
            id: 52,
            title: "Dealer Portal",
            note: [
                {
                    text1: `The Dealer Portal in the context of American First Finance (or similar financial services companies) serves as an online platform for merchants and retailers (dealers) to manage their customer financing applications and transactions. The portal allows dealers to offer financing options to their customers directly, providing tools to streamline the approval process, track applications, and manage payments.

Here are some of the key purposes and features of a Dealer Portal:

<b>1. Customer Financing Application Management</b>
Dealers can submit customer applications for financing and track their approval status in real time.

It helps process loan/credit applications quickly, allowing customers to get financing options for their purchases.

<b>2. Access to Financing Products</b>
Dealers can offer various financing options (e.g., retail installment contracts, lease purchase agreements) to their customers through the portal.

The portal usually includes tools to select the best product for the customer based on their needs and credit profile.

<b>3. Transaction Monitoring and Reporting</b>
Dealers can monitor the status of ongoing transactions and payment histories.

It provides dealers with analytics and reports to help manage the sales and financing process efficiently.

<b>4. Customer Support Tools</b>
Some dealer portals offer communication features that allow dealers to support customers directly via the portal.

Dealers can answer questions, assist with payment plans, and provide additional services related to financing.

<b>5. Integration with Sales Systems</b>
The dealer portal can often be integrated with the dealer's existing point-of-sale (POS) system, making the process of offering financing smooth and efficient.

Dealers can easily apply for credit approvals while customers are purchasing goods.

<b>6. Track and Manage Payments</b>
Dealers can track the payments made by customers who financed their purchases through American First Finance.

They can also monitor the status of past-due payments and communicate with customers if needed.

<b>7. Promotions and Special Offers</b>
Some dealer portals provide promotional tools, allowing dealers to offer special financing rates or deals during specific promotional periods.`,
                    code1: ``
                }
            ],
        },
        {
            id: 52,
            title: "Universal app",
            note: [
                {
                    text1: `<b>1. Start With the Project Overview</b>
Explain the context of the project and the goal of the Universal Web App.

Example: "I worked on the development of the Universal Web App for American First Finance, which was aimed at providing customers with a seamless and accessible way to manage their financing agreements, make payments, and track their accounts. The app was designed to be user-friendly and available across multiple devices, ensuring that users could access their financial information from anywhere."

<b>2. Describe Your Role and Responsibilities</b>
Explain your specific role as a frontend developer in the project.

<v>Example</b>: "As a frontend developer, I was responsible for the design, development, and maintenance of the user interface (UI) of the Universal Web App. My role included collaborating with the design team to implement visually appealing and user-friendly interfaces, as well as ensuring the app was responsive and optimized for various screen sizes."

<b>3. Highlight the Technologies You Used</b>
Mention the technologies, tools, and frameworks you worked with.

<v>Example</b>: "We used a modern stack for this project, including React.js for building dynamic and reusable UI components, TypeScript for adding type safety, and Redux for state management. I also worked with CSS/SCSS to style the components and used Material-UI for some of the component libraries to speed up development. We followed an Agile methodology to ensure continuous delivery and frequent iterations."

<b>4. Explain the Development Process and Methodologies</b>
Talk about the development process, collaboration, and any tools you used for version control and project management.

<v>Example</b>: "I followed Agile Scrum methodology, where I worked in two-week sprints. We used JIRA for task management, Git/GitHub for version control, and held regular stand-up meetings to ensure that the team was aligned. I collaborated closely with backend developers to ensure the frontend integrated seamlessly with the APIs and with designers to ensure the application matched the intended user experience."

<b>5. Challenges You Faced and How You Overcame Them</b>
Discuss any challenges you faced during the development process and how you solved them.

<v>Example</b>: "One challenge we faced was ensuring that the app was responsive and worked well across various devices, especially since customers would use the app on desktops, tablets, and mobile phones. I worked closely with the UX/UI team to implement a mobile-first design, using flexbox and media queries to ensure responsiveness. Additionally, optimizing the app's performance to handle a large volume of concurrent users was key, so I utilized code splitting and lazy loading to improve the load time."

<b>6. Collaboration and Communication</b>
Explain how you worked with other team members, such as backend developers, designers, and project managers.

<v>Example</b>: "I worked collaboratively with the backend developers to integrate APIs for handling customer data, payment information, and real-time notifications. We used RESTful APIs for communication between the frontend and backend. I also communicated closely with the design team to ensure that the app's user interface was consistent with the brand's guidelines and easy to navigate."

<b>7. Impact and Results</b>
If possible, talk about the impact your work had on the project or the company.

<v>Example</b>: "As a result of the app's successful development and deployment, we saw a significant improvement in customer engagement, with a higher adoption rate of the financing services. The app's user-friendly interface and ease of use led to a noticeable increase in customer satisfaction. Additionally, the app's smooth integration with backend systems allowed for quicker processing of customer requests, improving overall operational efficiency."

<b>8. Learnings and Skills Gained</b>
Discuss what you learned from the experience and how you grew as a developer.

<v>Example</b>: "This project helped me improve my skills in frontend development, particularly with React.js and TypeScript, as well as in performance optimization and responsive design. I also gained valuable experience working in an Agile environment, collaborating with cross-functional teams, and developing production-ready applications."

<v>Example</b> Answer:
Here's an example of how you might frame your response during an interview:

"In my previous role as a frontend developer at American First Finance, I had the opportunity to contribute to the development of the Universal Web App, which was designed to offer customers easy access to their financing accounts, payments, and account management. My primary responsibilities included building the user interface using React.js and TypeScript while ensuring the app was responsive and optimized for a variety of devices. I worked closely with backend developers to integrate APIs, as well as with the design team to ensure the UI matched the brand's aesthetic and was user-friendly.

One of the challenges I faced was optimizing the app for performance, especially as we needed it to handle a large volume of concurrent users. To address this, I implemented code splitting and lazy loading, which helped reduce the initial load time and improve the overall user experience. We also followed an Agile workflow, which allowed for continuous improvement and quick iterations. By the end of the project, the app was successfully launched and led to increased customer engagement, with higher adoption rates of financing services. It was a rewarding experience, and I gained a lot of hands-on knowledge in React, TypeScript, and performance optimization."`,
                    code1: ``
                }
            ],
        },
        {
            id: 52,
            title: "Clipboard Events",
            note: [
                {
                    text1: ``,
                    code1: ``
                }
            ],
        },
        {
            id: 1,
            title: "React js Interview Topics",
            note: [
                {
                    text1: `<b>React.js</b>

    React Lifecycle Methods (Class & Functional components with hooks)
    React Hooks (useState, useEffect, useMemo, useCallback, useContext, useRef, useReducer)
    Component Optimization (React.memo, useMemo, useCallback, Virtual DOM)
    State Management (Props, Context API, Redux, Zustand, Recoil)
    React Router (Dynamic Routes, Lazy Loading)
    Error Boundaries
    HOC (Higher-Order Components) & Render Props
    Performance Optimization (Code Splitting, Lazy Loading, Concurrent Mode)

TypeScript:
    Types & Interfaces (Basic Types, Unions, Intersection, Generics)
    Utility Types (Partial, Omit, Pick, Record, Readonly)
    Type Assertions & Type Guards (typeof, instanceof, in)
    Function Overloading
    Handling Props & State in React with TypeScript

JavaScript

    ES6+ Features (Destructuring, Spread, Rest, Async/Await, Modules)
    Closures & Lexical Scope
    Prototype & Prototypal Inheritance
    Event Loop & Asynchronous JavaScript
    Promises & Callbacks
    Debounce & Throttle
    Shallow & Deep Copy (JSON.parse/stringify, structuredClone, lodash)
    Map, Filter, Reduce
    Hoisting & Temporal Dead Zone (TDZ)
    WeakMap & WeakSet

Redux

    Redux Flow (Actions, Reducers, Store, Middleware)
    Redux Toolkit (createSlice, createAsyncThunk)
    Middleware (Redux-Thunk vs Redux-Saga)
    Connecting Redux with React (useSelector, useDispatch)
    Immer.js (Immutable State Updates)
    When to Use Redux vs Context API

Mock Interview Questions

‚úÖ React

    What is the difference between controlled and uncontrolled components?
    How does useEffect work? What is the dependency array?
    How do you prevent unnecessary re-renders in React?
    Explain React Fiber and how it improves performance.
    Difference between React context and Redux?

‚úÖ TypeScript
6. What is the difference between type and interface in TypeScript?
7. How does generics work? Can you give an example?
8. How to define React component props with TypeScript?
9. What are Mapped Types in TypeScript?

‚úÖ JavaScript
10. Explain event delegation in JavaScript.
11. How does debouncing and throttling work?
12. Explain the difference between == and ===.
13. What is the difference between var, let, and const?
14. What are JavaScript Design Patterns?

‚úÖ Redux
15. What are Redux Middleware and their use cases?
16. What is the difference between Redux and Redux Toolkit?
17. Explain Redux-thunk vs Redux-saga.
18. How does reducer composition work?`
                }
            ]
        },
        {
            id: 52,
            title: "Clipboard Events",
            note: [
                {
                    text1: `When preparing for an interview involving Playwright, a popular tool for automating web applications and end-to-end testing, you can expect questions that assess both your knowledge of Playwright and general testing principles. Here‚Äôs a list of possible Playwright interview questions, broken down into categories:

Basic Playwright Knowledge
What is Playwright?

Playwright is an open-source automation library for end-to-end testing of web applications. It supports multiple browsers (Chromium, Firefox, WebKit) and offers rich features like intercepting network requests, generating screenshots, and simulating user interactions.

How does Playwright differ from Selenium?

While Selenium is widely used for automating browsers, Playwright is designed to be faster, more reliable, and capable of automating multiple browsers (Chromium, WebKit, Firefox) with a single API. Playwright also provides more features out of the box like capturing screenshots, recording videos, and more robust browser interaction (e.g., multiple contexts).

What browsers are supported by Playwright?

Playwright supports Chromium, WebKit (Safari), and Firefox.

What are the key features of Playwright?

Cross-browser testing (Chromium, WebKit, Firefox)

Automated screenshots and screen recordings

Network interception and mocking

Simulating multiple devices and geolocation

Headless browser support

Handling pop-ups, alerts, and navigation events

Custom wait mechanisms (e.g., wait for elements, navigation)

Playwright API Questions
What is browser.newContext() used for?

browser.newContext() creates a new browser context. A context is like an isolated session, where cookies, storage, and other browser data are kept separate from other contexts. It‚Äôs useful for scenarios like simulating multiple users or testing in incognito mode.

How do you handle file uploads in Playwright?

Playwright allows handling file uploads by setting the file path for the input element in the form.

await page.setInputFiles('input[type="file"]', 'path/to/file');
What is the purpose of page.waitForSelector()?

page.waitForSelector() waits for an element to appear in the DOM before performing actions on it. This is essential for ensuring the element is present before interacting with it (e.g., clicking a button).

await page.waitForSelector('.button');
await page.click('.button');
How do you handle network requests in Playwright?

You can intercept network requests and responses with Playwright‚Äôs route feature. This allows for mocking responses or manipulating requests.

await page.route('**/api/**', (route) => {
  route.fulfill({
    status: 200,
    contentType: 'application/json',
    body: '{"message": "success"}'
  });
});
Test Automation Concepts
What are Playwright Test Fixtures?

Playwright Test Fixtures are reusable pieces of code that help set up the state for tests (like opening a browser, logging in, or setting up mock data) and can be shared between tests.

How do you run Playwright tests in parallel?

Playwright supports parallel test execution out of the box using Playwright Test Runner. You can configure the number of parallel workers in the playwright.config.js file.

test('test 1', async ({ page }) => {
  await page.goto('https://example.com');
});

test('test 2', async ({ page }) => {
  await page.goto('https://example.com/another-page');
});
You can also set workers to control the level of parallelism.

How do you run Playwright tests headlessly?

Playwright runs in headless mode by default, meaning it doesn‚Äôt display a browser window. However, you can explicitly set it with the headless option.

const browser = await playwright.chromium.launch({ headless: true });
Explain the role of test.beforeAll() and test.afterAll()?

These hooks are used to set up or clean up resources before or after all tests in a test suite.

test.beforeAll(): Executes once before the first test.

test.afterAll(): Executes once after the last test.

How do you use Playwright‚Äôs locator API?

The locator API allows you to target elements more efficiently than using page.$() or page.$$().

const button = page.locator('button#submit');
await button.click();
Advanced Playwright Topics
What is Playwright's headless mode?

In headless mode, Playwright runs the browser without a graphical user interface (GUI), which is useful for automation tasks, continuous integration, and faster tests.

How do you handle pop-ups or modals in Playwright?

Playwright automatically handles pop-ups (like alerts and dialogs). You can listen for events like dialog to interact with them:

page.on('dialog', async dialog => {
  await dialog.accept(); // Accept the dialog
});
How do you test mobile devices using Playwright?

You can simulate mobile devices by using the device option provided by Playwright, which mimics real mobile behaviors (like viewport size and touch events).

const iphone = playwright.devices['iPhone 12'];
await page.emulate(iphone);
What is the context in Playwright, and how do you use it?

A browser context allows multiple independent sessions (like multiple users) within the same browser instance. Each context has its own cookies, storage, and cache.

const context = await browser.newContext();
const page = await context.newPage();
Playwright vs. Other Testing Tools
What are the advantages of Playwright over Selenium and Cypress?

Speed: Playwright tends to be faster because it uses native browser interactions and provides better support for headless browsers.

Cross-Browser Testing: Playwright supports Chromium, Firefox, and WebKit, allowing cross-browser testing.

Native Mobile Support: Playwright supports testing on mobile devices out of the box.

Network Interception: Playwright provides better support for network request interception and manipulation.

Parallel Execution: Playwright can run tests in parallel more easily compared to Selenium or Cypress.

Behavior-Driven Development (BDD) with Playwright
How do you use Playwright with BDD frameworks like Cucumber?

Playwright can be used alongside Cucumber.js to run behavior-driven tests. You can write features in Gherkin syntax and map them to step definitions in JavaScript using Playwright to interact with the web.

Performance and Troubleshooting
How do you capture performance metrics with Playwright?

Playwright provides access to performance metrics through the page.metrics() method, which gives you details about the page‚Äôs performance.

How do you debug Playwright tests?

You can use Playwright's built-in debugging tools like page.pause() to pause test execution at a certain point and inspect the state of the page.

await page.pause();  // This will pause the test execution for interactive debugging
Practical Coding Questions
Write a Playwright script to log into a website and check if a user dashboard is displayed.

Create a test that performs a form submission and verifies the result on the page.

Write a Playwright script to intercept API requests and mock responses for a login API.`,
                    code1: ``
                }
            ],
        },
        {
            id: 52,
            title: "Clipboard Events",
            note: [
                {
                    text1: ``,
                    code1: ``
                }
            ],
        },
        {
            id: 52,
            title: "my Cognizant details",
            note: [
                {
                    text1: `18005720473 () it infra support


GSD no- 1800-572-0473
 passwordreset@cognizant.com or  Infravoiceleads@cognizant.com  


 associate id
 2410407@cognizant.com
 **** Srihashemmu@123# *****
 

 OneITRequestFulfil(Cognizant) <OneITRequestFulfil@cognizant.com>
 
 https://onecognizant.cognizant.com/Home
 
 https://cognizantonline.sharepoint.com/sites/Be.Cognizant/SitePages/Home.aspx
 
 oneCognizant
 
 Associate 360 App
 peopleSoft HCM protal 
 BNC app
 
 
 trueTime vs ESA Timesheet
 
 project : Telstra T25 WP1 CSCE Build`,
                    code1: ``
                }
            ],
        },
        {
            id: 52,
            title: "Cognizant",
            note: [
                {
                    text1: `Business continuity management
                    
                    <b>Global Business Resilience - Planning & Recovery (GBR PnR)</b> is the process by which a company prepares for and recovers from unexpected disruptions, like natural disasters, cyberattacks, or economic crises. It involves making sure that the business can keep running or quickly get back on track after a problem.`,
                    code1: ``
                },
                {
                    text1: ``,
                    code1: ``
                },
                {
                    text1: ``,
                    code1: ``
                },
                {
                    text1: ``,
                    code1: ``
                },
                {
                    text1: ``,
                    code1: ``
                },
            ],
        },
        {
            id: 52,
            section: 'Core Skills of a Software Engineer',
            title: "Core Skills of a Software Engineer",
            note: [
                {
                    text1: `<b>üîß Core Skills of a Software Engineer</b>
<b>1. Programming Proficiency</b>
    Languages: Python, Java, C++, JavaScript, etc.
    Depth: Writing clean, maintainable, testable code.
    Understanding of: Data types, control flow, functions, OOP, error handling, etc.

<b>2. Data Structures & Algorithms</b>
    Arrays, Linked Lists, Stacks, Queues
    Trees (BST, AVL), Graphs
    Sorting/searching algorithms, Recursion, Dynamic programming
    Time & space complexity (Big O notation)
‚úÖ Why it matters: Enables you to build efficient and scalable solutions.

<b>3. System Design</b>
    Designing software architecture:
        Microservices vs Monolith
        Load balancing, caching, databases, queues
    Understand scalability, fault tolerance, distributed systems
‚úÖ Why it matters: Helps build systems that handle real-world traffic and complexity.

<b>4. Version Control</b>
    Tools: Git, GitHub/GitLab/Bitbucket
    Concepts: Branching, merging, pull requests, resolving conflicts
‚úÖ Why it matters: Enables collaboration and code history tracking.

<b>5. Software Development Lifecycle (SDLC)</b>
    Phases: Requirements ‚Üí Design ‚Üí Implementation ‚Üí Testing ‚Üí Deployment ‚Üí Maintenance
    Agile/Scrum methodology
    CI/CD pipelines
‚úÖ Why it matters: Teaches discipline and team collaboration.

<b>6. Databases</b>
    SQL (Structured): PostgreSQL, MySQL
    NoSQL (Document-based): MongoDB, Firebase
    Knowledge of indexes, joins, normalization
‚úÖ Why it matters: Almost every system stores and retrieves data.

<b>7. Testing</b>
    Unit tests (PyTest, JUnit)
    Integration tests
    Test-Driven Development (TDD)
‚úÖ Why it matters: Prevents bugs and ensures reliability.

<b>8. Problem Solving & Analytical Thinking</b>
    Critical thinking to break down problems
    Logical flow of execution
    Debugging complex issues
‚úÖ Why it matters: Engineers are paid to solve problems, not just write code.

<b>9. Communication</b>
    Writing clear documentation
    Explaining complex ideas to non-tech teams
    Code reviews and technical discussions
‚úÖ Why it matters: Software engineering is a team sport.

<b>10. DevOps & Deployment (Optional but Valuable)</b>
    Docker, Kubernetes, Jenkins
    AWS / Azure / GCP
    Monitoring tools (Grafana, Prometheus)
‚úÖ Why it matters: Helps engineers understand production and delivery aspects.

<b>11. Security Awareness</b>
    Understand common attacks: SQL injection, XSS, CSRF
    Writing secure code
    Data protection and access control
‚úÖ Why it matters: Security is essential for real-world software.

<b>Bonus Soft Skills:</b>
    Time management
    Teamwork
    Curiosity and continuous learning`,
                    code1: ``
                },
                {
                    text1: ``,
                    code1: ``
                },
                {
                    text1: ``,
                    code1: ``
                },
                {
                    text1: ``,
                    code1: ``
                },
                {
                    text1: ``,
                    code1: ``
                },
            ],
        },

        {
            id: 52,
            title: "what is Software architecture",
            note: [
                {
                    text1: `Software Architecture defines fundamental organization of a system and more simply defines a structured solution. It determines how the various components of a software system are assembled, how they relate to one another, and how they communicate. Essentially, it serves as a blueprint for the application and a foundation for the development team to build upon.
                    
                    <b>Software architecture</b> is the <b>big-picture design</b> of how software will be <b>structured, behave, and grow over time.</b>
                    
                    
                    <b>üß± Architectural Patterns </b> :
                    	Learn 
                        Monolithic, 
                        Layered, 
                        Microservices, 
                        Event-driven, etc.
<b>üß© Design Patterns</b>
	Understand Singleton, Factory, Observer, MVC, etc.
<b>üìê SOLID Principles</b>
	Improve code architecture and maintainability
<b>üéØ System Design Basics</b>
	Concepts like scalability, load balancing, caching, etc.
`,
                    code1: ``
                },
            ],
        },
        {
            id: 52,
            title: "Design Patterns",
            note: [
                {
                    text1: `<b>What is a Design Pattern?</b>
A design pattern is a general, reusable solution to a commonly occurring problem in software design. It's not a finished piece of code, but a template or blueprint for how to solve a particular design issue in different situations.

Key Points:
    Design patterns <b>represent best practices</b> refined through experience.
    They <b>speed up development</b> by providing proven development paradigms.
    They <b>promote code reusability, scalability, and maintainability</b>.
    They are <b>language-independent</b>‚Äîthough their implementations may differ.

     Categories of Design Patterns:
    <b>Creational Patterns</b> ‚Äì Object creation mechanisms.
        Examples:
            <b>Singleton</b> ‚Äì Ensure a class has only one instance.
            <b>Factory Method</b> ‚Äì Delegate object creation to a subclass.
            <b>Builder</b> ‚Äì Build complex objects step-by-step.
            <b>Prototype</b> ‚Äì Clone existing objects.

    <b>Structural Patterns</b> ‚Äì How objects and classes are composed.
        Examples:
            <b>Adapter</b> ‚Äì Bridge between incompatible interfaces.
            <b>Decorator</b> ‚Äì Add behavior without altering original class.
            <b>Facade</b> ‚Äì Simplified interface to a complex subsystem.

    <b>Behavioral Patterns</b> ‚Äì How objects interact and communicate.
        Examples:
            <b>Observer</b> ‚Äì Notify many objects about state changes.
            <b>Strategy</b> ‚Äì Encapsulate interchangeable behaviors.
            <b>Command</b> ‚Äì Encapsulate a request as an object.
    `,
                    code1: `// ------------  Example (Singleton in JavaScript): ------------
                    class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
      this.counter = 0;
    }
    return Singleton.instance;
  }

  increment() {
    this.counter++;
    return this.counter;
  }
}

const instance1 = new Singleton();
const instance2 = new Singleton();

console.log(instance1.increment()); // 1
console.log(instance2.increment()); // 2 ‚Äî Same instance!


// ---------- Ex : 2 -----------
    let counter = 0
    const count = Object.freeze({
      getCount: () => counter,
      increment: () => ++counter,
      decrement: () => --counter
    })

    count.increment(); // 1
    count.increment(); // 2
    count.increment(); // 3
    console.log(count.getCount()); // 3
`
                },
                {
                    text1: ``,
                    code1: ``
                }
            ],
        },
        {
            id: 52,
            title: "What is an Architectural Pattern?",
            note: [
                {
                    text1: `An <b>Architectural Pattern</b> is a <b>high-level design solution</b> used to organize and structure <b>software systems</b>. It provides a reusable blueprint for how components and layers of an application should <b>interact, communicate</b>, and <b>separate concerns.</b>`,
                    code1: ``
                }
            ],
        },
        {
            id: 52,
            title: "Software Development Life Cycle (SDLC) Models.",
            note: [
                {
                    text1: `<b>SDLC Models</b> are structured approaches or methodologies used to guide the development of software through a series of phases like planning, design, development, testing, and maintenance.
                    
                    <b>Software Development Life Cycle</b> or Systems Development Life Cycle (SDLC) is a systematic process IT teams use to design, develop, test, and deploy high-quality software.
                    
    <b>Common SDLC Models include</b>:
    Waterfall Model
    Agile Model
    Spiral Model
    V-Model (Verification and Validation)
    Incremental Model
    Iterative Model
    Big Bang Model
    RAD (Rapid Application Development) Model

                    Software Development Life Cycle (SDLC) is a structured process that is used to design, develop, and test high-quality software. SDLC, or software development life cycle, is a methodology that defines the entire procedure of software development step-by-step. The goal of the SDLC life cycle model is to deliver high-quality, maintainable software that meets the user's requirements.

SDLC in software engineering models outlines the plan for each stage so that each stage of the software development model can perform its task efficiently to deliver the software at a low cost within a given time frame that meets users requirements. In this article we will see Software Development Life Cycle (SDLC) in detail.

What is the Software Development Life Cycle (SDLC)?
SDLC is a process followed for software building within a software organization. SDLC consists of a precise plan that describes how to develop, maintain, replace, and enhance specific software. The life cycle defines a method for improving the quality of software and the all-around development process.  

<b>Stages of the Software Development Life Cycle</b>
SDLC specifies the tasks to be performed at various stages by a software engineer or developer. It ensures that the end product is able to meet the customer's expectations and fits within the overall budget. Hence, it's vital for a software developer to have prior knowledge of this software development process. SDLC is a collection of these six stages, and the stages of SDLC are as follows:
`,
                    code1: ``,
                    img: `../assets/images/software/SDLC.jpg`
                },
                {
                    text1: `<b>Stages of the Software Development Life Cycle</b>
SDLC specifies the tasks to be performed at various stages by a software engineer or developer. It ensures that the end product is able to meet the customer's expectations and fits within the overall budget. Hence, it's vital for a software developer to have prior knowledge of this software development process. SDLC is a collection of these six stages, and the stages of SDLC are as follows:

<b>Stage 1: Planning and Requirement Analysis</b>
Planning is a crucial step in everything, just as in software development. In this same stage, requirement analysis is also performed by the developers of the organization. This is attained from customer inputs, and sales department/market surveys. 
The information from this analysis forms the building blocks of a basic project. The quality of the project is a result of planning. Thus, in this stage, the basic project is designed with all the available information.

<b>Stage 2: Defining Requirements</b>
In this stage, all the requirements for the target software are specified. These requirements get approval from customers, market analysts, and stakeholders. 
This is fulfilled by utilizing SRS (Software Requirement Specification). This is a sort of document that specifies all those things that need to be defined and created during the entire project cycle. 

<b>Stage 3: Designing Architecture</b>
SRS is a reference for software designers to come up with the best architecture for the software. Hence, with the requirements defined in SRS, multiple designs for the product architecture are present in the Design Document Specification (DDS). 
This DDS is assessed by market analysts and stakeholders. After evaluating all the possible factors, the most practical and logical design is chosen for development.

<b>Stage 4: Developing Product</b>
At this stage, the fundamental development of the product starts. For this, developers use a specific programming code as per the design in the DDS. Hence, it is important for the coders to follow the protocols set by the association. Conventional programming tools like compilers, interpreters, debuggers, etc. are also put into use at this stage. Some popular languages like C/C++, Python, Java, etc. are put into use as per the software regulations. 

<b>Stage 5: Product Testing and Integration</b>
After the development of the product, testing of the software is necessary to ensure its smooth execution. Although, minimal testing is conducted at every stage of SDLC. Therefore, at this stage, all the probable flaws are tracked, fixed, and retested. This ensures that the product confronts the quality requirements of SRS. 
Documentation, Training, and Support: Software documentation is an essential part of the software development life cycle. A well-written document acts as a tool and means to information repository necessary to know about software processes, functions, and maintenance. Documentation also provides information about how to use the product. Training in an attempt to improve the current or future employee performance by increasing an employee's ability to work through learning, usually by changing his attitude and developing his skills and understanding. 

<b>Stage 6: Deployment and Maintenance of Products</b>
After detailed testing, the conclusive product is released in phases as per the organization‚Äôs strategy. Then it is tested in a real industrial environment. It is important to ensure its smooth performance. If it performs well, the organization sends out the product as a whole. After retrieving beneficial feedback, the company releases it as it is or with auxiliary improvements to make it further helpful for the customers. However, this alone is not enough. Therefore, along with the deployment, the product's supervision. `,
                    code1: ``,
                    img: `../assets/images/software/6-Stages-of-Software-Development-Life-Cycle.jpg`
                }
            ],
        },
        {
            id: 52,
            title: "Waterfall & Agile Model",
            note: [
                {
                    text1: ``,
                    code1: ``
                }
            ],
        },
        {
            id: 52,
            title: "English",
            note: [
                {
                    text1: `<b>1. Grammar & Sentence Structure</b>
    Sometimes you skip articles (‚Äúa‚Äù, ‚Äúthe‚Äù) or prepositions (‚Äúon‚Äù, ‚Äúat‚Äù, ‚Äúin‚Äù) in your sentences.
    Example: You wrote "I am i good in english" ‚Üí Correct: "Am I good in English?" or "Do you think I‚Äôm good at English?"

    Practice forming complete questions and statements with correct word order.

<b>2. Vocabulary & Expressions</b>
    Your words are understandable, but they‚Äôre often basic or direct.
    Expand with synonyms and natural phrases.
    Example: Instead of "keep flowers", say "place flowers" or "offer flowers".

<b>3. Tenses & Consistency</b>
    Sometimes you mix present and past tense.
    Example: "I came back he is not responding" ‚Üí "I came back, but he wasn‚Äôt responding."

<b>4. Polishing for Formal/Professional Use</b>
    Use polite connectors and transitions, especially for work or interviews.
    Example: Instead of "What can fill here", use "What should I fill in here?".

<b>5. Listening & Speaking Practice</b>
    Watch English shows, YouTube explainers, and TED Talks with subtitles.
    Repeat aloud to copy pronunciation and flow.
    Record your own voice and check clarity.`,
                    code1: ``
                }
            ],
        },
        {
            id: 52,
            title: "SOLID principles",
            note: [
                {
                    text1: `<b>SOLID principles</b> of Software Architecture
Each character of the word SOLID defines one principle of software architecture. The SOLID principles are key guidelines for creating well-structured, maintainable software architectures This SOLID principle is followed to avoid product strategy mistakes. A software architecture must adhere to SOLID principle to avoid any architectural or developmental failure.

<b>Single Responsibility </b>- Each services or module should have only one responsibility or purpose .
<b>Open-Closed Principle </b>- Software modules should be independent and expandable.
<b>Liskov Substitution Principle </b>- Objects or services should be interchangeable without altering the correctness of the system.
<b>Interface Segregation Principle </b>- Software should be divided into such microservices there should not be any redundancies.
<b>Dependency Inversion Principle </b>- Higher-levels modules should not be depending on low-lower-level modules and changes in higher level will not affect to lower level.

`,
                    code1: ``,
                    img: `../assets/images/software/SOLID.png`
                },
                {
                    text1: ``,
                    code1: ``
                },
                {
                    text1: ``,
                    code1: ``
                }
            ],
        },
        {
            id: 1,
            title: "programs",
            note: [
                {
                    text1: ``,
                    code1: `// ---------- Ex : -------------
                    class MinimumBalanceError(Exception):  # Correct spelling
                        pass

                    class Account:
                        AccNum = 1001

                        def __init__(self, name, account_number, balance):
                            self.name = name
                            self.account_number = Account.AccNum  # Use class name to access class variable
                            self.balance = balance
                            Account.AccNum += 1  # Increment class variable

                        def deposit(self, amount):
                            self.balance += amount

                        def withdraw(self, amount):
                            if self.balance - amount <= 1000:
                                raise MinimumBalanceError("Minimum Balance should be at least 1000")
                            self.balance -= amount

                        def show_details(self):
                            return f"{self.account_number}, {self.name}, {self.balance}"

                    # Using try-except to handle exception
                    cc = Account("ram", 1002, 1200)
                    cc.deposit(1500)

                    try:
                        cc.withdraw(2000)
                    except MinimumBalanceError as e:
                        print("Withdrawal Error:", e)

                    print(cc.show_details())
`
                }
            ]
        },
    ]
}